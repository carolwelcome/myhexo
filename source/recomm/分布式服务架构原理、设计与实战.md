Java世界里，实现AOP的三种方式：
```
1、对Java字节码进行听重新编译，将切面插入字节码的某些点和面上，可以使用cglib库实现
2、定制类加载器，在类加载时对字节码进行补充，在字节码中插入切面，增加了除业务逻辑外的功能，JVM自身提供的Java Agent机制就是在加载类的字节码时，通过增加切面 来实现AOP
3、JVM本身提供了动态代理组件 ，可以通过它实现任意对象的代理模式，在代理的过程中可以插入切面 的逻辑。可以使用Java提供的APIProy.newProxyInstance()，和InvocationHandler来实现。

```

AspectJ是实现AOP的专业框架和平台，通过AspectJ可以实现任意方式的字节码切面 ，Spring框架完全支持AspectJ



spring的ioc机制的理解

根据xml配置或者注册的形式来实例化所有对象bean,管理bean之间的依赖注入，让类与类之间解耦，维护代码的时候可以更加的轻松便利
核心的servlet

spring的aop机制的理解
AOP的核心技术 就是动态代理，动态代理思路：动态的创建一个代理类出来，创建这个代理类的实例对象，在这个代理类里面引用自己真正的类，所有的方法调用 ，都是先走代理类的对象，他负责做一些代码上的增强，再去调用你写的那个类。
动态代理技术 cglib，jdk动态代理

cglib:在sprign里使用aop,

如果类实现 了某个接口，spring aop会使用jdk动态代理，在类有接口的时候就使用jdk动态代理

在类没有实现接口的时候 ，spring aop使用cglib来生成动态代理，生成该类的一个子类，动态生成字节码，覆盖本类的一些方法，在方法里加入增强代码 。

jdk动态代理示例代码 
cglib动态代理示例代码

工厂类一般就是被设计为单例

工厂模式包含工厂方法和抽象工厂，属于创建型模式
策略模式属于行为型模式

工厂模式主要目的 是封装好创建逻辑 ，策略模式接收工厂创建好的对象，从而实现 不同的行为
创建new
行为invoke

策略模式是委派模式内部的一种实现 形式，策略模式关注 的是否能相互替代 

支付方式 

委派模式更关注 分发和高度的过程 
有可能采用if。。else条件 来分发，内部 也可以用策略模式来替代if else


工厂方法模式是模板方法模式的一种特殊实现 ，模板方法限定执行顺序，

模板 方法和策略模式都 有封装算法 
策略模式是使用不同算法 可以相互替换 ，且不影响客户端应用层的使用

模板方法是针对定义一个算法 的流程，将一些有细微 差异 的部分交给子类实现 ，策略模式算法实现是封闭的

模板模式不能改变算法流程，策略模式可以改变 算法 流程且可。策略模式通用来代替if else等条件 分支语句 



装饰者模式和静态代理模式

装饰者模式关注点在于给对象动态扩展，添加方法，而代理更加注重控制对象的访问
代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰对象当成是构造方法的参数


spring wrapper不一定是装饰者模式


装饰者与适配器模式
装饰者模式和适配器模式都属于包装器模式
装饰者模式可以实现被装饰者与相同的接口或者继承被装饰都作为它的子类，而适配器和被适配者可以实现不同的接口






















