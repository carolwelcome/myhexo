#### 如何在分布式场景下生成全局唯一ID
##### 全局ID特点
+ 全局唯一
+ 递增（特殊场景如事务版本号，使用索引时）
+ 高可用
+ 信息安全（由于生成的ID是连续的，所以很容易看出来数据量有多少；
+ 越短越好

##### 如何生成
+ 利用数据库生成

	利用数据库的自增长序列，生成唯一主键，通过服务提供给其他系统，适用于数据总量，并发量都不是很大的情况。
	如果每次生成一个ID可能会对数据库有压力，可以考虑一次性成生N个ID放到缓存中，如果缓存中的ID被取光，再通过数据库生成下一批
	
	优点：理解容易，实现简单
	
	缺点：数据库迁移比较麻烦；并发量到一定级别之后会有性能问题；自增ID无业务含义；连续；
	
+ 利用其他组件（软件/中间件）生成

	利用redis/MongoDB/ZooKeeper生成：Redis利用incr和increby;MongoDB的ObjectId；zk通过znode数据版本；都可以生成全局的唯一标识码。
	
	优点：性能高于数据库；可以使用集群部署；Id内自带一些含义（时间戳）
	
	缺点：和数据库一样，需要引入对应的组件/软件，增加了系统的复杂度；生成全局唯一ID的系统（服务），会成为一个单点，有风险；
	
+ UUID

	生成唯一标识码最常用的算法。生成因素包括：MaC地址、时间戳、命名空间、随机或伪随机数、时序等元素。
	
	优点：本地生成，没有网络消耗，不需要第三方组件 ，生成简单、性能好
	
	缺点：长度长，不利于存储，相对来说还会影响性能（作为索引时）
	
+ Snowflake
	
	解决了ID本地生成，又不和UUID那样无序--->Snowflake算法
	SnowFlake 算法生成 ID 是一个 64 bit 的整数，包括：
	
	1 bit ：不使用，固定是 0；
	41 bit ：时间戳（毫秒），数值范围是：0 至 2的41次方 - 1；转换成年的话，大约是 69 年；
	10 bit ：机器 ID ；5 位机房 ID + 5 位机器 ID；（服务集群数量比较小的时候，可以手动配置，服务规模大的话，可以采用第三方组件进行自动配置，比如美团的 Leaf-snowflake，就是通过 ZooKeeper 的持久顺序节点做为机器 ID）
	12 bit ： 序列号，用来记录同一个毫秒内生成的不同 ID。
	
	在Java中，SnowFlake 算法生成的 ID 正好可以用 long 来进行存储
	![snowflake](record_files/1.png)
	
	此外，还有很多优秀的互联网公司也提供了唯一 ID 生成的方案或框架，比如美团开源的 Leaf，百度开源的 UidGenerator 等等。
